<?xml version="1.0" encoding="UTF-8"?>
<designer-settings revision="2">
   <node class="net.sourceforge.pmd.util.fxdesigner.MainDesignerController">
      <property name="recentFiles" type="java.util.List&lt;java.io.File&gt;">
         <value/>
      </property>
      <property name="maximized" type="boolean">
         <value value="true"/>
      </property>
      <node class="net.sourceforge.pmd.util.fxdesigner.ScopesPanelController"/>
      <node class="net.sourceforge.pmd.util.fxdesigner.SourceEditorController">
         <property name="auxclasspathFiles" type="java.lang.String">
            <value value=""/>
         </property>
         <node class="net.sourceforge.pmd.util.fxdesigner.app.services.ASTManagerImpl">
            <property name="sourceCode" type="java.lang.String">
               <value value="class Foo {&#xA;&#xA;  /*&#xA;    This is a custom designer crafted to diff between the prototype Java grammar&#xA;    for 7.0.0 and the current grammar. You can see both trees to the right.&#xA;    Node selection should be in sync. Also there's a javadoc viewer on the left.&#xA;    (also there's a nicer XPath export wizard but I only include it&#xA;     because that branch fixes some critical performance issues)&#xA;&#xA;    The 6.0.x tree can be color-coded to highlight differences. Key:&#xA;    * Red: removed node. Turned into an interface in the code most of the time.&#xA;    * Yellow: proposed removal, to be thought about&#xA;&#xA;    Those are all nodes whose presence doesn't add anything to the tree and&#xA;    which in all cases were worked around in rules. Using interfaces declutters&#xA;    the tree, removes inconsistencies, and makes it look like more of an AST&#xA;    than a parse tree.&#xA;&#xA;    I ran some benchmarks to compare the old parser to this one.&#xA;    * Parsing performance is equivalent&#xA;    * ASTs are on average about 60% as big (they're smaller)&#xA;      * They're also around 3 to 6 nodes less deep, depending on the metric&#xA;    * Since the AST is more compact, the runtime of a full visitor traversal&#xA;      is decreased on average by 12%&#xA;&#xA;  */&#xA;&#xA;&#xA;    /*&#xA;       EXPRESSIONS&#xA;       * Full changelog at the bottom&#xA;     */&#xA;&#xA;    {&#xA;        // Literals&#xA;&#xA;        long l = 0 + 0l;   // NumericLiteral&#xA;        double d = l * 0d; // VariableReference&#xA;        String f = &#34;  &#34;;   // StringLiteral&#xA;        char c = 'c';      // CharLiteral&#xA;        Object o = null;   // NullLiteral&#xA;        boolean b = true;  // BooleanLiteral&#xA;        Class&lt;String&gt; klass = String.class;     // ClassLiteral&#xA;&#xA;        // ParenthesizedExpression/NullLiteral&#xA;        // easier than Expression/PrimaryExpression/PrimaryPrefix/Expression/PrimaryExpression/PrimaryPrefix/Literal/NullLiteral&#xA;        Object k = (null);&#xA;&#xA;&#xA;        // AdditiveExpression implements #1661&#xA;        // A new level is pushed every time the operator changes&#xA;        // So this is flat:&#xA;        int q = l + b + 0 + c;&#xA;        // But this has two levels:&#xA;        q = l + b - 0 - c;&#xA;&#xA;        // Same for MultiplicativeExpression&#xA;        q = 2 * 3 * b / 1;&#xA;&#xA;        // ArrayAllocation and ConstructorCall replace AllocationExpression&#xA;&#xA;        // ArrayAllocation&#xA;        int[] is = new int[] {1, 2};&#xA;        is = new int[2];&#xA;&#xA;        // ConstructorCall&#xA;        me = new Foo();&#xA;        // qualified constructor call&#xA;        me = me.new Inner();&#xA;        // anonymous class&#xA;        me = me.new Inner() {&#xA;            // qualified this&#xA;            String outerName = Foo.this.myName;&#xA;        };&#xA;&#xA;        // notice that &#34;me&#34; in the assignments above is not syntactically&#xA;        // ambiguous, must be a variable because we assign to it&#xA;&#xA;        // SuperExpression, MethodCall&#xA;        // &#34;super&#34; is exactly symmetric to &#34;this&#34;&#xA;        super.fooo();&#xA;        Any.super.bar();&#xA;&#xA;        // FieldAccess with a ThisExpression as LHS&#xA;        // Also, AssignmentExpression&#xA;        this.myName = &#34;foo&#34;;&#xA;        // ThisExpression&#xA;        Object me = this;&#xA;&#xA;&#xA;        // array type, array initializer&#xA;        // look at how many levels are removed from the array initializer&#xA;        int[][] js = {{1, 2}, {3}, is, null};&#xA;&#xA;        // ArrayAccess&#xA;        js[1] = js[0 + 0]; // notice &#34;js&#34; is not syntactically ambiguous&#xA;&#xA;        // Lambda&#xA;        Consumer&lt;String&gt; fun = s -&gt; {&#xA;            // AmbiguousName&#xA;            // more explanations are given in the changelog at the bottom&#xA;            System.out.println(s.length()); // s is unambiguous bc the parameter is in scope&#xA;        };&#xA;&#xA;        // method reference, ambiguous&#xA;        foo(System.out::println);&#xA;        // here &#34;String&#34; is unambiguously a type name (bc of &#34;new&#34;)&#xA;        foo(String::new);&#xA;        // But here, &#34;java.lang&#34; is ambiguous between package or type name&#xA;        foo(java.lang.String::new);&#xA;&#xA;        // ShiftExpression&#xA;        // no more RUNSIGNEDSHIFT/RSIGNEDSHIFT&#xA;        int shifted = l &gt;&gt; 2;&#xA;        shifted = shifted &gt;&gt;&gt; 3;&#xA;&#xA;        // UnaryExpression&#xA;        // UnaryExpressionNotPlusMinus is removed, it was an accident of the grammar&#xA;        boolean not = !!true;&#xA;        shifted = -shifted / ~shifted;&#xA;        // should we merge Pre[In|De]crementExpression into UnaryExpression?&#xA;        // they have the same precedence, and there's no counterpart for&#xA;        // PostIncrement &amp; PostDecrement, which makes it look inconsistent&#xA;        shifted = --shifted + shifted--;&#xA;    }&#xA;&#xA;&#xA;    /*&#xA;       ANNOTATIONS&#xA;       * Turn Annotation into an interface&#xA;       * Remove Name nodes, useless in all cases&#xA;       * Remove MemberValuePairs. MemberValuePair may only occur in&#xA;         NormalAnnotation so that node added no information.&#xA;       * TBH we could also merge NormalAnnotation, MarkerAnnotation and SingleMemberAnnotation&#xA;         into a single node. It's not very useful to separate them that way. We could have&#xA;         a single node &#34;Annotation&#34;, with the following grammar:&#xA;         Annotation        := &#34;@&#34; &lt;Name #void&gt; [ AnnotationMembers ]&#xA;         AnnotationMembers := &#34;(&#34; (Expression | (MemberValuePair)*) &#34;)&#34;&#xA;           So eg&#xA;           @Foo              ~&gt; Annotation&#xA;           @Foo()            ~&gt; Annotation { AnnotationMembers }&#xA;           @Foo(&#34;foo&#34;)       ~&gt; Annotation { AnnotationMembers { StringLiteral } }&#xA;           @Foo(value=&#34;foo&#34;) ~&gt; Annotation { AnnotationMembers { MemberValuePair { StringLiteral } } }&#xA;&#xA;         Wdyt?&#xA;     */&#xA;&#xA;    @SomeAnnot()&#xA;    @SomeAnnot(name = &#34;foo&#34;, arr = {@B})&#xA;    @Single(&#34;foo&#34;)&#xA;    @java.lang.Override&#xA;    String myName = &#34;name&#34;;&#xA;&#xA;&#xA;&#xA;    /*&#xA;      TYPES&#xA;      * ClassOrInterfaceTypes are now left-recursive. They use AmbiguousName&#xA;        too, because some segments need to be disambiguated between package&#xA;        or type name&#xA;      * TypeArgument, WildcardBound and TypeBound are removed, replaced with WildcardType&#xA;        and IntersectionType&#xA;    */&#xA;&#xA;    // Wildcard types&#xA;    List&lt;?&gt; abc;&#xA;    List&lt;? extends B&gt; abc2;&#xA;    List&lt;? super B&gt; abc3;&#xA;    // Array types&#xA;    List&lt;String&gt;[] sss1;&#xA;    List&lt;String&gt; @Foo [] sss2;&#xA;&#xA;&#xA;    // Class or interface types&#xA;&#xA;    // the qualifier is ambiguous&#xA;    // pretty easy to classify though (I didn't bother with @SemanticCheck here)&#xA;    java.util.List&lt;String&gt; sss3;&#xA;    java.util.Map.Entry sss5;&#xA;    java.util.Map&lt;String, String&gt;.Entry&lt;String, String&gt; sss6;&#xA;    // this parses now, but not with the old parser (#1367)&#xA;    // java.util.Map.@Foo Entry sss5;&#xA;&#xA;    // Intersection types&#xA;&#xA;    // This type parameter is an IntersectionType&#xA;    &lt;T extends Foo &amp; Bar&gt; void foo(T t) {&#xA;        Object me = null;&#xA;&#xA;        // Intersection types in casts&#xA;        me = (@B Foo) me;&#xA;        me = (@B Foo &amp; Bar) me;&#xA;        me = (Foo &amp; Bar) me;&#xA;    }&#xA;}&#xA;&#xA;&#xA;    /*&#xA;&#xA;Changelog for the Expression grammar&#xA;  * Make ASTVariableInitializer, ASTExpression, ASTPrimaryExpression, ASTLiteral interfaces&#xA;  * Implement #1661 for MultiplicativeExpression and AdditiveExpression&#xA;  * Introduce new node types:&#xA;    * ASTClassLiteral, ASTNumericLiteral, ASTStringLiteral, ASTCharLiteral&#xA;      * those divide the work of ASTLiteral, they implement it along with preexisting ASTBooleanLiteral, ASTNullLiteral&#xA;    * ASTFieldAccess&#xA;      * Only when it has a LHS, e.g. &#34;a.b&#34;&#xA;      * Only pushed when we're certain this cannot be a FQCN or type member&#xA;    * ASTVariableReference&#xA;      * Unqualified reference to a variable&#xA;    * ASTAmbiguousName&#xA;      * For those names that are *syntactically* ambiguous&#xA;      * Most of them aren't semantically ambiguous, even with no auxclasspath, meaning&#xA;        they can be rewritten to a more meaningful node (a VariableReference or FieldAccess).&#xA;        The attribute AmbiguousName/@SemanticCheck makes a (very simple) disambiguation&#xA;        using the current (full of holes) symbol table and other easy to grab stuff:&#xA;        * If there's a variable in scope with the name, then it's classified as EXPR&#xA;        * Otherwise, if there's a static import with the given name, then it's classified as EXPR&#xA;        * Otherwise, if there's an import with the given name, it's classified as TYPE&#xA;        * Otherwise, it's classified as AMBIGUOUS&#xA;        * Many scenarios where there's no ambiguity without auxclasspath are not covered&#xA;        * With an auxclasspath and a proper symbol table, we could reclassify them all&#xA;&#xA;        This is a very simple prototype, any real implementation would use the more precise&#xA;        JLS rules and some more heuristics.&#xA;        I found that nevertheless, around 90% of syntactically ambiguous names are&#xA;        semantically unambiguous using those simple rules (that was observed on several&#xA;        large codebases). This is without any auxclasspath support.&#xA;&#xA;    * ASTMethodCall&#xA;      * Doesn't use ASTArguments anymore, ASTArgumentsList is enough&#xA;    * ASTParenthesizedExpression&#xA;    * ASTArrayAccess&#xA;    * ASTAssignmentExpression&#xA;    * ASTArrayAllocation, ASTConstructorCall&#xA;      * those replace ASTAllocationExpression&#xA;    * ASTThisExpression, ASTSuperExpression&#xA;      * those enclose their qualifier if any&#xA;  * Remove unnecessary node types:&#xA;    * ASTPrimarySuffix and ASTPrimaryPrefix&#xA;      * they're productions, not nodes&#xA;    * ASTUnaryExpressionNotPlusMinus&#xA;      * Merged into ASTUnaryExpression&#xA;    * ASTAssignmentOperator&#xA;      * made obsolete by ASTAssignmentExpression&#xA;    * ASTArguments&#xA;      * To remove it, ASTExplicitConstructorInvocation must be changed too&#xA;    * ASTVariableInitializer&#xA;      * Is superseded by ASTExpression, through making ASTArrayInitializer implement ASTExpression.&#xA;        This is only logical, they're expressions according to JLS. See deprecation note.&#xA;    * ASTRSIGNEDSHIFT, ASTRUNSIGNEDSHIFT&#xA;    * ASTAllocationExpression&#xA;      * The concrete node is replaced by ASTConstructorCall and ASTArrayAllocation, though we could make it an interface instead of removing it&#xA;*/&#xA;"/>
            </property>
            <property name="languageVersion" type="net.sourceforge.pmd.lang.LanguageVersion">
               <value value="java 11"/>
            </property>
         </node>
      </node>
      <node class="net.sourceforge.pmd.util.fxdesigner.MetricPaneController"/>
      <node class="net.sourceforge.pmd.util.fxdesigner.NodeJavadocController"/>
      <node class="net.sourceforge.pmd.util.fxdesigner.RuleEditorsController">
         <property name="selectedTabIndex" type="int">
            <value value="0"/>
         </property>
         <nodeseq name="ruleSpecs">
             <node class="net.sourceforge.pmd.util.fxdesigner.model.ObservableXPathRuleBuilder">
               <property name="name" type="java.lang.String">
                  <value value="VerboseArrayInitializer"/>
               </property>
               <property name="xpathExpression" type="java.lang.String">
                  <value value="(: This matches array allocs that may be replaced with just the initializer (#1495) :)&#xA;//VariableDeclarator[parent::*/ArrayType][ArrayAllocation/ArrayInitializer]&#xA;"/>
               </property>
               <property name="description" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="xpathVersion" type="java.lang.String">
                  <value value="2.0"/>
               </property>
               <property name="language" type="net.sourceforge.pmd.lang.Language">
                  <value value="java"/>
               </property>
               <property name="externalInfoUrl" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="priority" type="net.sourceforge.pmd.RulePriority">
                  <value value="3"/>
               </property>
               <property name="message" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="clazz" type="java.lang.Class&lt;?&gt;">
                  <value value="net.sourceforge.pmd.lang.rule.XPathRule"/>
               </property>
               <property name="since" type="java.lang.String">
                  <value value=""/>
               </property>
               <nodeseq name="ruleProperties"/>
            </node>
            <node class="net.sourceforge.pmd.util.fxdesigner.model.ObservableXPathRuleBuilder">
               <property name="name" type="java.lang.String">
                  <value value="VerboseArrayInitializer"/>
               </property>
               <property name="xpathExpression" type="java.lang.String">
                  <value value="//VariableDeclarator&#xA;[parent::*/Type/ReferenceType[@Array=true()]]&#xA;[VariableInitializer/Expression/PrimaryExpression/PrimaryPrefix/AllocationExpression/ArrayDimsAndInits/ArrayInitializer]&#xA;"/>
               </property>
               <property name="description" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="xpathVersion" type="java.lang.String">
                  <value value="2.0"/>
               </property>
               <property name="language" type="net.sourceforge.pmd.lang.Language">
                  <value value="oldjava"/>
               </property>
               <property name="externalInfoUrl" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="priority" type="net.sourceforge.pmd.RulePriority">
                  <value value="3"/>
               </property>
               <property name="message" type="java.lang.String">
                  <value value=""/>
               </property>
               <property name="clazz" type="java.lang.Class&lt;?&gt;">
                  <value value="net.sourceforge.pmd.lang.rule.XPathRule"/>
               </property>
               <property name="since" type="java.lang.String">
                  <value value=""/>
               </property>
               <nodeseq name="ruleProperties"/>
            </node>
         </nodeseq>
      </node>
      <node class="net.sourceforge.pmd.util.fxdesigner.NodeDetailPaneController">
         <property name="hideCommonAttributes" type="boolean">
            <value value="true"/>
         </property>
      </node>
   </node>
</designer-settings>